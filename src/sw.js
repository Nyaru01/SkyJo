import { precacheAndRoute, cleanupOutdatedCaches, createHandlerBoundToURL } from 'workbox-precaching';
import { clientsClaim } from 'workbox-core';
import { registerRoute, NavigationRoute } from 'workbox-routing';

// Version marker
const SW_VERSION = '1.2.3-fcm-force-v3';
console.log(`‚öôÔ∏è [SW] Service Worker ${SW_VERSION} Loading...`);

// Precache all assets generated by Vite
precacheAndRoute(self.__WB_MANIFEST, {
    ignoreURLParametersMatching: [/.*/]
});

// Forcer la mise √† jour imm√©diate pour appliquer les nouveaux SenderID
// REMOVED (2024-02-14) : Cause un red√©marrage forc√© brutal pour l'utilisateur. 
// On laisse le prompt PWA (UpdatePrompt.jsx) g√©rer l'activation via SKIP_WAITING message.
// self.addEventListener('install', () => {
//     self.skipWaiting();
// });

// Cleanup old caches
cleanupOutdatedCaches();

// Allow headers to take control immediately
clientsClaim();

const handler = createHandlerBoundToURL('/index.html');
const navigationRoute = new NavigationRoute(handler);
registerRoute(navigationRoute);

self.addEventListener('message', (event) => {
    if (event.data && event.data.type === 'SKIP_WAITING') {
        self.skipWaiting();
    }
});

/**
 * Robust Push Notification Listener (Natif)
 * Handles FCM Data Messages WITHOUT crashing on undefined properties.
 */
self.addEventListener('push', (event) => {
    console.log('========================================');
    console.log('üîî [SW] MESSAGE PUSH RE√áU');

    let payload = {};
    if (event.data) {
        try {
            payload = event.data.json();
        } catch (e) {
            console.warn('[SW] Erreur parsing JSON:', e);
            payload = { data: { body: event.data.text() } };
        }
    }

    console.log('üîî Payload brut:', JSON.stringify(payload, null, 2));

    // Extraction des donn√©es (Gestion FB/FCM : payload.data ou payload)
    let data = payload.data || payload;

    // Parfois FCM imbrique encore dans data.data
    if (data.data && typeof data.data === 'object' && !data.title) {
        console.log('‚ö†Ô∏è [SW] Donn√©es doubl√©es d√©tect√©es');
        data = data.data;
    }

    console.log('üì¶ [SW] Donn√©es extraites:', data);

    // S√©curisation contre les "undefined" (Cause du crash pr√©c√©dent)
    const title = data.title || 'üéÆ Skyjo Score';
    const body = data.body || 'Nouvelle notification';
    const roomId = data.roomId || '';
    const invitationId = data.invitationId || '';

    // L'URL cible (/?room= est le standard de l'app)
    const targetUrl = data.url || (roomId ? `/?room=${roomId}` : '/');
    const tag = data.tag || `skyjo-inv-${roomId || 'gen'}-${Date.now()}`;

    console.log('üöÄ [SW] URL cible:', targetUrl);

    const options = {
        body: body,
        icon: '/pwa-192-v5.png',
        badge: '/badge-72.png',
        tag: tag,
        data: {
            url: targetUrl,
            roomId: roomId,
            invitationId: invitationId,
            sentAt: data.sentAt,
            tag: tag
        },
        renotify: true,
        requireInteraction: true,
        vibrate: [200, 100, 200],
        sound: '/sounds/notification.mp3'
    };

    console.log('üìã [SW] Affichage notification:', title);
    console.log('========================================');

    event.waitUntil(
        Promise.all([
            self.registration.showNotification(title, options),
            data.sentAt ? fetch('/api/push/track', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    type: 'receive',
                    invitationId: invitationId,
                    sentAt: data.sentAt,
                    receivedAt: Date.now()
                })
            }).catch(e => console.warn('[SW] Erreur track:', e)) : Promise.resolve()
        ])
    );
});

/**
 * Handle Notification Clicks
 */
self.addEventListener('notificationclick', (event) => {
    console.log('========================================');
    console.log('üëÜ [SW] CLIC SUR NOTIFICATION');

    // Fermer la notification imm√©diatement
    event.notification.close();

    // Donn√©es de la notification
    const data = event.notification.data || {};
    const targetUrl = data.url || '/';

    console.log('üëÜ Donn√©es associ√©es:', data);
    console.log('========================================');
    console.log('üéØ [SW] URL cible:', targetUrl);

    // Strat√©gie ultra-robuste pour mobile :
    // On tente d'ouvrir ou de recharger imm√©diatement.
    event.waitUntil(
        clients.matchAll({ type: 'window', includeUncontrolled: true })
            .then((clientList) => {
                // Si une fen√™tre est d√©j√† l√†, on tente de la r√©activer
                for (let client of clientList) {
                    if (client.url.includes(self.location.origin) && 'focus' in client) {
                        console.log('‚úÖ [SW] Fen√™tre trouv√©e, focus...');
                        return client.focus().then(c => {
                            c.postMessage({ type: 'DEEP_LINK', url: targetUrl });
                            return c;
                        });
                    }
                }

                // Sinon, ou si le focus a √©chou√©, on ouvre une nouvelle fen√™tre (le plus fiable sur mobile)
                if (clients.openWindow) {
                    const fullUrl = new URL(targetUrl, self.location.origin).href;
                    console.log('üÜï [SW] Ouverture directe:', fullUrl);
                    return clients.openWindow(fullUrl);
                }
            })
            .catch(err => {
                console.error('‚ùå [SW] Erreur de navigation:', err);
                // Dernier recours : tenter au moins d'ouvrir l'accueil
                if (clients.openWindow) return clients.openWindow('/');
            })
    );
});

self.addEventListener('notificationclose', (event) => {
    console.log('‚úñÔ∏è [SW] Notification ferm√©e');
});